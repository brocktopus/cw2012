# Programming as Composing (with) New Media

Kevin Brock (kevin_brock@ncsu.edu)
* North Carolina State University
* Presented at: Computers & Writing, 2012

## Introduction

Scholars of rhetoric and composition have spent the last decade expanding beyond the conventional boundaries of the discipline: image (Fleckenstein), sound (Halbritter), games (Gee), and visual design (Kress and van Leeuwen) have all been incorporated into composition theory and practice, with a tremendous amount of scholarship focused on multimodal works (Shipka) created in a variety of media, especially digital media. As Kathleen Yancey has observed, these varied methods of composition have an even wider variety of purposes, and many students often practice far more with emerging technologies and forms of communication than we might be willing to use in the classroom. 

One particularly significant – although generally overlooked – communicative form is the range of computer code languages that, through their compilation into executable software programs, enable and constrain our digital communications. As instructors, we demonstrate interest and suggest value in engaging in such communication, but as a whole we've been slow to discuss the levels of architecture and action that oversee end-user methods of composition. In this presentation, I'll discuss how programming languages are rhetorically powerful forms of composition, situate them within courses on writing and rhetoric, and offer demonstrations of actual programs created by students. 

## Programming, Procedure, Pisteis

At the heart of software is operational procedure, the expression of an algorithm in order to interpret some output from an initial input. An algorithm is a procedure whose execution is made possible by a set of conditions that influence subsequent steps and conditions within the procedure. Software programs are made up of thousands of such procedures, often relying on dynamic interrelations of data and user interactions with constructed interfaces to build a meaningful experience for that user. 

This intent – meaningful activity through software use – is squarely in-line with the goals of rhetoric and composition, since software operation is an increasingly available, and effective, means of persuasion for a digitally-involved population. There have been several proposals to consider more explicitly the potential for software, and the programming thereof, as a valid part of composition and its work. Ian Bogost argues for "[procedural rhetoric](http://mitpress.mit.edu/books/chapters/0262026147chap1.pdf)" as a means of understanding how interactive systems (like video games) engage us in learning about how the rules of procedure enable us to evaluate successful routes of action within those systems. Annette Vee suggests that "[proceduracy](http://annettevee.com/research.html)" is a valid literacy for contemporary students who need to understand how computers work in order to succeed in the 21st century. David Berry makes a similar case for "[iteracy](http://stunlaw.blogspot.com/2011/09/iteracy-reading-writing-and-running.html)" as a means of understanding how to apply procedural rules across large bodies of data in the manner of algorithmic expression. The canons of invention and arrangement work procedurally for conventional arguments: rhetors determine what conditions are likely to be most accepted by a given audience and structure their case in an ordered path that facilitates the optimal response to each step in the argumentative procedure. 

The affordances and constraints of code upon software functionality and user experience are available means of persuasion working in line with the fundamental principles of digital technologies: the coding rhetor deals with the arrangement of algorithm, user input and response, and (potentially) dynamic manipulation of data. Computers enable us to persuade not merely by mixing together multiple modes of communication or to offer user interaction with our texts, but rather by constructing, through code languages, the procedural frameworks through which we can invent novel and complex means of persuasively engaging our audiences.

## Programming as Composing

Some will argue that code functions primarily, if not exclusively, as mechanical operation devoid of, or outside the realm of, persuasion; one cannot convince a machine that a particular calculation (and the mathematical nature of calculation cannot be understated here) could ever have any value than its rigidly-determined solution. For others, it is the argument that end use reflects more accurately than code the relationship students have with computers. These arguments both have weight, but they also underestimate the possibility of programming as a rhetorically rich and significant form of writing and composing as well as of interactive communication. Donald Knuth, inventor of LaTeX and WEB/CWEB, has long suggested that code has literate, aesthetic value and should be approached as an art. Yukihiro Matsumoto, the initial developer of Ruby, argues that code – like natural writing – is primarily designed for human readers, and it is incidental that it can be executed by machines. Coders around the world engage regularly in arguments about how “best” to style their code for human audiences as well as for computational efficiency.

So how can a mathematical process, or an assembled mass of such processes, offer rhetorical value and serve as a type of “composition”? Further, how could it benefit writing instructors, especially those who may feel overburdened by the implicit need to include in their syllabi multiple modes and venues for academic and civic genres of communication? First, code allows for a more exposed, and (perhaps ironically) more accessible “machine,” as the mechanisms of code are manipulated in anticipation of user behavior when interacting with the compiled code as software program. Second, code provides a means of exploring and implementing dynamic procedure, what might best be called a flexible algorithm, constrained in part by, and constraining, individual input as a key variable in its expression. Third, code is a (perhaps the) foundational component of digital media, and including it in a writing course situates it very differently than an instructor might discuss it in a computer science course. Rather than focusing on becoming expert programmers, writing students learning to code would learn both the basics of how programming logic works and how coders communicate meaningfully with others, and themselves, in and through code. 

The third benefit may be the most daunting: it demands of instructors a familiarity with how code works, and by extension, at least one language that might be accessible enough for students to learn the basics of as part of a single-semester course. This is tricky, since the higher the level of a programming language, the more abstracted it can appear from the machine operations it describes. 

## Courses & Projects

For the 2011-2012 school year, I was involved in the instruction of two courses focused on introducing students to code from a humanities perspective. The first was a course on interdisciplinary perspectives called "[Introduction to Humanities Physical Computing](https://github.com/brocktopus/ip295)," which I co-taught with David Rieder. We taught students how to think more critically about the capabilities of digital technologies to help us “make things” digital and physical in nature, and this was accomplished with the aid of the [Arduino](http://arduino.cc) microprocessor and the [Processing](http://www.processing.org) IDE (Integrated Development Environment), which is a simplified version of the Java language. Students in the course had majors ranging from English to Chemical Engineering to Business Management. 

Students in the course created projects fulfilling practical and experimental purposes alike, and their work was fueled by a desire to explore just how code languages, electrical sensors, and human intent work together to create meaningful experiences. One group of students constructed a simple robot that demanded attention like a newborn: if it could not sense an object in its proximity, through a PIR sensor or photosensors on its “hair” blocking ambient light, it would begin to wail. Another group built a synthesizer that developed melodies out of inputted text; their goal was to make music out of their names or from natural discourse. These students learned how to write in multiple forms of code, of programming languages and electrical resistance: they constructed experiences that made persuasive cases, physically and digitally, for meaningful reflection on the topics they considered important. 

The second code-related writing course I taught was an upper-level English/Communication course entitled "[Code, Computation, and Rhetoric](https://raw.github.com/brocktopus/engcom395)." The course's explicit focus was to introduce students to rhetorical and computational principles and examine how they relate. Students were taught the Processing IDE and fundamentals of programming alongside examples of computational art, music, and literature. They engaged in critical analysis as well as creative composition, applying their growing understanding of rhetoric to algorithmic procedure.

One student created a quiz that offered the user two answer choices to each question; the chosen answers influenced the emergence of a visual collage in a space beneath the quiz as the user progressed. What appeared initially to be a set of binary choices dissolved into a complex assemblage of character-based reflection, and the student created her program with a focus on constraint and rhetorical repetition, hoping to force her user, through the act of choosing answers, to see what sorts of limitations are placed upon him or her through contemporary technologies. The student also noted that this project served to allow her to consider constraint in a similar fashion, as she learned more about how computers facilitated and restricted various types of behavior or activity through code.

A group of students produced their own Pac-Man-style game in which a mouse runs around a house and eats pieces of cheese. Unlike Pac-Man, however, the students' mouse gets slower as it eats more cheese until, after eating the last piece, it can no longer move. The group's goal was to have users think about why they play games and what sorts of incentives are provided for doing so. The procedural rhetoric of the “cheese eater” game offers a significantly distinct ethos than most other games.
 
While these projects could have been made without exposure to a code language like Processing, they would have been quite different. The student who made her quiz, for example, noted that studying and understanding boolean logic provided her with a radically different perspective than if she'd tried to create her quiz in HTML. The game creators learned how the influences of distinct variables – how many pieces of cheese were uneaten, how many pixels the mouse would move with each press of a particular key, and so on – have the potential to create significant changes in behavior across their game system. This was especially tricky for the game group, as they attempted to work on different components of the game (a timer, cheese-eating affecting speed, wall barriers to restrict movement) individually and periodically provide updates for one another.

Yet another student decided to look more closely at the specifics of Processing syntax and structure as a means of studying rhetoric. Interested in specific rhetorical devices and how they are used, she devised a simple “click the correct block” game that made meaningful use of repetition both in terms of code and in terms of game play. She did this by creating two versions of the game: one that populated each block individually, and one that made use of loops to iteratively construct batches of blocks. The latter method would be referred to as the comparatively “elegant” way of coding, by saving time, space, and energy to establish the rules for block-building in the game. However, the former method employs a much more nuanced use of repetition: a loop provides all elements thereof with a unified set of rules for their collective construction, but coding each block separately enables the coder to provide unique and potentially disparate rules for each. This sort of distinction may not ever be noticed by the user (assuming he or she played both versions of the game), but the difference in code is profound. 

## Conclusions

 These examples touch on the surface of potential when we consider programming as a form of composing and as a rhetorically meaningful means of communication. When incorporated into a writing curriculum, students learning rhetoric in an increasingly digital society have at their disposal a fundamental understanding of algorithmic procedure and code-based composition in order to achieve rhetorical action. Without it, students may be able to work within new media environments, but they are not innovating to the extents possible beyond the “surface” level of interface. Do they have to do so in order to successfully communicate in or through digital technologies? Not necessarily – but if we want them to know the available means of persuasion, we need to interrogate how code works rhetorically and how our compositions in/of new media are constrained by that working.
